/**
 * Structures to provide a simple interface for C++ classes.
 */

// TODO: Inline struct/enum support

// Very very very bad :)
function __name_function(name, func) {
  Object.defineProperty(func, "name", { value: name });
}

function Structure(pointer, fields) {
  return {
    pointer,
    fields,
  };
}

function Field(name, type, bytes = 1, offset = null) {
  return {
    name,
    bytes,
    type,
    offset,
  };
}

function _getStructureProxy(pointer, name) {
  return new Proxy(
    {
      dump: () => {
        let prefix = "  ";
        const _line = (message, isField = true) =>
          printf(`${prefix.repeat(isField)}${message}`);

        let metadata = globalThis[name];
        let fields = metadata.fields;
        let keys = Object.keys(fields);

        _line(`${name}(${pointer}):`, false);

        for (let key of keys) {
          let field = fields[key];
          _line(
            `- [${Add(pointer, field.offset)}${
              field.bytes != null ? ` : ${field.bytes * 8}` : ""
            }] ${field.type} ${field.name} ${
              field.type == "Pointer"
                ? `= ${Memory.read64(Add(pointer, field.offset))}`
                : ""
            }`
          );
        }
      },
    },
    {
      [Symbol.toPrimitive](_) {
        return null;
      },

      get: (target, property, _) => {
        let metadata = globalThis[name];

        if (metadata == null || property == "dump") return target[property];

        let prefix = `${name}(${pointer}):`;

        if (!Object.keys(metadata.fields).includes(property))
          throw TypeError(`${prefix} Unknown property: ${property}`);

        let field = metadata.fields[property];
        pointer = Add(pointer, field.offset);

        switch (field.type) {
          case "Data":
          case "Pointer":
            return pointer;
          default:
            if (globalThis[field.type] == null)
              throw TypeError(`${prefix} Unable to grab type: (${field.type})`);
            return globalThis[field.type](pointer);
        }
      },
    }
  );
}

function newStructure(name, fields, inherits = "") {
  let baseOffset = 0;
  let ancestor = null;
  if (inherits != "" && globalThis != null) {
    ancestor = globalThis[inherits];
    baseOffset = ancestor.totalSize;
  }

  let offset = baseOffset;

  let fieldMap = {};
  for (let field of fields) {
    field.offset = offset;
    fieldMap[field.name] = field;
    offset += 8 * field.bytes;
  }

  if (ancestor != null)
    fieldMap = {
      ...ancestor.fields,
      ...fieldMap,
    };

  // Can't be a class because we need to get our dynamic name
  const _construct = function (object) {
    return _getStructureProxy(Memory.addrof(object), arguments.callee.name);
  };

  _construct.bits = offset - baseOffset;
  _construct.baseOffset = baseOffset;
  _construct.totalSize = offset;
  _construct.fields = fieldMap;

  __name_function(name, _construct);

  globalThis[name] = _construct;
}

newStructure("JSCell", [
  Field("m_structureID", "Data", 4),
  Field("m_indexingTypeAndMisc", "Data"),
  Field("m_type", "Data"),
  Field("m_flags", "Data"),
  Field("m_cellState", "Data"),
]);

newStructure("JSObject", [Field("m_butterfly", "Pointer", 8)], "JSCell");

newStructure("JSArrayBuffer", [Field("m_impl", "Pointer", 8)], "JSObject");

newStructure("JSCallee", [Field("m_scope", "Pointer", 8)], "JSObject");

newStructure(
  "JSFunction",
  [Field("m_executableOrRareData", "Pointer", 8)],
  "JSCallee"
);

newStructure(
  "ExecutableBase",
  [
    // TODO: JitCode
    Field("m_jitCodeForCall", "Pointer", 8),
    Field("m_jitCodeForConstruct", "Pointer", 8),
    Field("m_jitCodeForCallWithArityCheck", "Pointer", 8),
    Field("m_jitCodeForConstructWithArityCheck", "Pointer", 8),
  ],
  "JSCell"
);
